1
00:00:01,880 --> 00:00:02,480
同学们好

2
00:00:02,800 --> 00:00:05,480
欢迎来到java 课程课时一

3
00:00:05,960 --> 00:00:07,120
对象和封装

4
00:00:07,740 --> 00:00:09,500
该课时呢有以下几个考点

5
00:00:09,890 --> 00:00:12,410
分别为掌握类和对象的概念

6
00:00:12,450 --> 00:00:13,490
和类图介绍

7
00:00:13,970 --> 00:00:15,810
掌握构造方法及其重载

8
00:00:16,050 --> 00:00:18,010
掌握封装的概念及其使用

9
00:00:18,790 --> 00:00:21,110
课时一呢虽然内容比较简单

10
00:00:21,920 --> 00:00:24,320
但是它是我们java 这门课的基础

11
00:00:24,760 --> 00:00:27,440
在考试题中呢频繁出现

12
00:00:28,000 --> 00:00:30,520
比如说我们做一些程序阅读啊

13
00:00:31,160 --> 00:00:32,400
一些程序编写的题目

14
00:00:32,840 --> 00:00:35,440
它是离不开这个对象和封装这个概念

15
00:00:36,530 --> 00:00:37,730
那比如说选择填空

16
00:00:37,930 --> 00:00:39,250
也是离不开这个概念

17
00:00:39,370 --> 00:00:41,820
所以说基本上每道题

18
00:00:41,820 --> 00:00:45,260
他的可能都会掺杂着这个知识点去考

19
00:00:45,990 --> 00:00:47,790
跟着老师的这个节奏呢

20
00:00:48,030 --> 00:00:49,990
把那个课时的内容听懂

21
00:00:50,790 --> 00:00:53,590
并且呢老师也会梳理这个例题

22
00:00:54,070 --> 00:00:56,230
然后留给大家一些课后习题

23
00:00:56,230 --> 00:00:57,590
大家要积极去完成

24
00:00:58,240 --> 00:00:59,880
我们来看正式的内容

25
00:01:00,640 --> 00:01:02,520
现实世界是由什么组成的呢

26
00:01:03,360 --> 00:01:04,080
有各种东西

27
00:01:04,800 --> 00:01:07,820
飞机呀船啊动物啊

28
00:01:08,500 --> 00:01:10,220
很多东西组成了我们这个世

29
00:01:10,260 --> 00:01:11,620
界的一个整体

30
00:01:12,200 --> 00:01:14,000
我们一句话去概括一下是什么东西

31
00:01:14,000 --> 00:01:16,920
就是世界是由对象组成的

32
00:01:17,750 --> 00:01:20,110
那为什么去使用面向对象呢

33
00:01:20,990 --> 00:01:22,310
在回答这个问题之前呢

34
00:01:22,310 --> 00:01:23,430
我要给大家解释一下

35
00:01:23,430 --> 00:01:25,110
我们java 是用来干什么

36
00:01:25,110 --> 00:01:26,950
java 其实是软件语言

37
00:01:27,430 --> 00:01:29,870
那软件我们是做什么的软件

38
00:01:29,870 --> 00:01:31,630
出现的目的就是用计算机语言

39
00:01:31,630 --> 00:01:33,350
去解决一个现实的问题

40
00:01:33,670 --> 00:01:34,790
去描述现实世界

41
00:01:35,270 --> 00:01:37,230
那我们java 这个面向对象的思想

42
00:01:37,230 --> 00:01:39,870
就是来描述面向对象的世界

43
00:01:40,450 --> 00:01:43,810
那这样更加符合我们人类的思维习惯

44
00:01:44,220 --> 00:01:46,500
也就是说我们这样去做的话

45
00:01:46,660 --> 00:01:48,860
我们面向对象去设计开发程序

46
00:01:48,860 --> 00:01:50,020
都是非常好的

47
00:01:50,430 --> 00:01:52,030
首先呢交流更加顺畅

48
00:01:52,510 --> 00:01:54,710
提高程序的设计和开发的效率

49
00:01:56,300 --> 00:01:58,020
看一下这个宠物图啊

50
00:01:58,340 --> 00:02:01,220
宠物呢我们有企鹅狗啊各种东西

51
00:02:01,340 --> 00:02:02,940
这一类宠物呢其实它就是

52
00:02:03,300 --> 00:02:04,420
现实世界的对象

53
00:02:04,820 --> 00:02:06,780
什么对象它是宠物类这个对象

54
00:02:07,560 --> 00:02:09,240
那如何在计算机中描述它们呢

55
00:02:09,639 --> 00:02:12,320
我们在现实世界中抽象出类

56
00:02:12,480 --> 00:02:13,400
其实分为三步

57
00:02:13,400 --> 00:02:14,720
我刚才说它是宠物类

58
00:02:15,440 --> 00:02:16,280
如何把这个类

59
00:02:16,480 --> 00:02:18,200
从现实世界中抽象出来呢

60
00:02:18,200 --> 00:02:19,680
我们看这幅图呢

61
00:02:19,840 --> 00:02:22,600
我们知道它其实都有共同的特点

62
00:02:22,980 --> 00:02:25,460
就是它都是我们的宠物

63
00:02:25,860 --> 00:02:28,380
那我们第一步就是说找出它的种类

64
00:02:28,580 --> 00:02:30,590
种类它都是动物啊

65
00:02:30,590 --> 00:02:32,190
其次我们要找出它的属性

66
00:02:32,510 --> 00:02:33,990
最后我们要找出他的行为

67
00:02:35,600 --> 00:02:37,240
我们怎么去做呢

68
00:02:37,360 --> 00:02:38,600
我们第一步发现类

69
00:02:38,880 --> 00:02:41,180
比如说这里面有很多的小狗

70
00:02:41,420 --> 00:02:43,300
那每个狗呢它都是一个对象

71
00:02:43,660 --> 00:02:45,740
整体的这些对象组成了一个什么类

72
00:02:46,040 --> 00:02:47,560
这个类是叫什么叫狗类

73
00:02:48,320 --> 00:02:50,040
狗类里面有很多不同的狗

74
00:02:50,710 --> 00:02:52,790
根据这个对象呢我们抽象出类了

75
00:02:53,150 --> 00:02:55,710
所以说我们走完了第一步就是发钱类

76
00:02:57,210 --> 00:02:58,970
第二步呢我们是发现属性

77
00:02:59,130 --> 00:03:01,170
比如说狗有哪些属性呢

78
00:03:01,580 --> 00:03:02,700
它有一些共有的属性

79
00:03:02,700 --> 00:03:05,740
就比如说是品种年龄昵称健康情况

80
00:03:05,740 --> 00:03:07,380
包括跟主人的一些亲密度

81
00:03:07,860 --> 00:03:08,860
那只跟我

82
00:03:08,860 --> 00:03:11,100
们具体的业务相关的属性有哪些呢

83
00:03:11,100 --> 00:03:13,100
比如说我们需要知道它的名字

84
00:03:13,380 --> 00:03:14,540
需要知道他的健康值

85
00:03:14,540 --> 00:03:15,620
需要知道它的亲密度

86
00:03:15,860 --> 00:03:17,140
需要知道它的品种

87
00:03:17,480 --> 00:03:18,960
这些都是它的一个属性

88
00:03:20,740 --> 00:03:21,500
那第三步呢

89
00:03:21,500 --> 00:03:23,380
我们发现这个类的方法就是狗

90
00:03:23,380 --> 00:03:24,380
这个类有哪些方法呢

91
00:03:24,380 --> 00:03:25,860
他可能会去跑啊

92
00:03:26,020 --> 00:03:26,620
去废呀

93
00:03:26,940 --> 00:03:28,580
还去输出一些信息呀

94
00:03:29,160 --> 00:03:30,040
在这些东西里面

95
00:03:30,040 --> 00:03:32,320
我给他提供一个方法就是print 

96
00:03:32,320 --> 00:03:34,360
方法就能够代表他的一些

97
00:03:34,720 --> 00:03:35,880
共有的一些行为

98
00:03:36,620 --> 00:03:37,740
通过这三个步骤呢

99
00:03:37,740 --> 00:03:40,500
其实我就能够抽象出狗这个类来

100
00:03:40,700 --> 00:03:42,140
这个方法其实就是类图

101
00:03:42,790 --> 00:03:43,550
大家可以看一下

102
00:03:44,110 --> 00:03:46,510
这个方框上面写了一个dog class

103
00:03:46,510 --> 00:03:47,510
dog 就是我们的类

104
00:03:47,810 --> 00:03:50,250
那下面写的这个name healthy lover string 

105
00:03:50,250 --> 00:03:52,610
就是我们刚才提出来的一些属性

106
00:03:52,830 --> 00:03:53,830
这个属性呢

107
00:03:53,910 --> 00:03:56,230
左边这个加号代表这个属性是公

108
00:03:56,390 --> 00:03:57,630
开可见的

109
00:03:57,930 --> 00:04:00,930
这个加号代表我们的访问修饰符是public 

110
00:04:01,050 --> 00:04:01,810
公开可见

111
00:04:02,010 --> 00:04:04,730
那后面每一个英文单词就是属性

112
00:04:04,730 --> 00:04:05,890
后面有一个冒号

113
00:04:05,890 --> 00:04:08,330
冒号后面有一个string int 等这些东西

114
00:04:08,330 --> 00:04:09,050
它是什么呢

115
00:04:09,250 --> 00:04:09,890
那代表我

116
00:04:09,890 --> 00:04:12,250
们现在这个属性的一个类型是什么

117
00:04:12,250 --> 00:04:14,610
比如说我们的名字就是string 类型的

118
00:04:14,850 --> 00:04:16,769
那我们的健康值是int 类型的

119
00:04:16,890 --> 00:04:18,570
那下面呢有一个横线

120
00:04:18,610 --> 00:04:20,050
横线下面有一个print 

121
00:04:20,050 --> 00:04:22,290
这个print 呢代表我们的方法

122
00:04:23,090 --> 00:04:25,010
通过这个三个步骤以后呢

123
00:04:25,010 --> 00:04:25,410
我们得到

124
00:04:25,410 --> 00:04:25,810
了一个

125
00:04:25,810 --> 00:04:27,730
狗类的清晰的一个设计的一个图

126
00:04:27,850 --> 00:04:28,690
就叫类图

127
00:04:29,190 --> 00:04:30,990
通过这个图更加容易

128
00:04:31,110 --> 00:04:32,830
直观去理解我们这个类

129
00:04:33,430 --> 00:04:34,510
大家可以看那个图啊

130
00:04:34,510 --> 00:04:35,350
很详细的啊

131
00:04:35,910 --> 00:04:37,070
类名类型

132
00:04:37,550 --> 00:04:40,350
属性名方法名等等等等我们都有啊

133
00:04:40,900 --> 00:04:43,260
后面这个word 代表它的返回值类型是word 

134
00:04:43,460 --> 00:04:44,500
是一个空的

135
00:04:46,760 --> 00:04:48,000
我们来看下对象初始化

136
00:04:48,560 --> 00:04:49,560
我们刚才第一步呢

137
00:04:49,560 --> 00:04:51,920
其实是通过对象出象出了类

138
00:04:52,470 --> 00:04:54,070
在知道有个类的情况下

139
00:04:54,070 --> 00:04:56,350
我们怎么样去获取这个对象呢

140
00:04:56,350 --> 00:04:56,870
我们就要

141
00:04:56,990 --> 00:04:59,230
利用这个对象初始化这个方法

142
00:04:59,480 --> 00:05:01,640
就是比如说我知道有企鹅这个类

143
00:05:01,880 --> 00:05:05,240
但是我要去实例化一个企鹅的对象

144
00:05:05,480 --> 00:05:07,480
哎就比如说我知道有人这个类

145
00:05:07,480 --> 00:05:09,600
但是我要把你去new 出来

146
00:05:09,910 --> 00:05:12,310
这个时候通过这个new 的方式啊

147
00:05:12,390 --> 00:05:14,590
new 一个企鹅的一个构造方法

148
00:05:14,630 --> 00:05:17,980
就能够获得这个pgn 1的这个企鹅啊

149
00:05:18,580 --> 00:05:19,980
这个是一个企鹅的对象

150
00:05:20,450 --> 00:05:21,690
这叫实例化对象

151
00:05:22,050 --> 00:05:23,770
那这个时候这个企鹅

152
00:05:24,010 --> 00:05:25,530
我们需要给它附一个名字

153
00:05:25,650 --> 00:05:27,930
比如说它需要有一个name 叫qq 

154
00:05:28,500 --> 00:05:29,500
他需要一个性别

155
00:05:29,500 --> 00:05:30,420
他是一个q 仔

156
00:05:30,970 --> 00:05:31,770
那这一切呢

157
00:05:31,770 --> 00:05:34,050
都是通过这个构造方法和这个

158
00:05:34,250 --> 00:05:36,690
点nm 的点sksex 的方式去完成的

159
00:05:36,690 --> 00:05:37,570
但是我们能

160
00:05:37,610 --> 00:05:39,810
不能通过其他的方式去做呢

161
00:05:40,350 --> 00:05:41,550
我们同样可以在这个

162
00:05:41,750 --> 00:05:44,510
构造方法中去给它输入这个name

163
00:05:44,670 --> 00:05:46,470
live sexy 等等一些东西

164
00:05:46,470 --> 00:05:47,710
去完成一些赋值

165
00:05:48,260 --> 00:05:50,540
就是说构造方法这里面的写完以后

166
00:05:50,990 --> 00:05:53,230
调用这个new 构造方法以后

167
00:05:53,230 --> 00:05:54,750
我们就解决了这些问题

168
00:05:54,750 --> 00:05:57,270
就不要在下面每一个都是点去复制

169
00:05:59,820 --> 00:06:00,580
构造方法呢

170
00:06:00,580 --> 00:06:02,820
我们去抽象一下看一下他的一个形式

171
00:06:02,820 --> 00:06:05,740
它有访问修饰符构造方法名

172
00:06:06,180 --> 00:06:08,060
和括号组成

173
00:06:08,660 --> 00:06:09,260
看一下啊

174
00:06:09,260 --> 00:06:10,780
其实它跟我们普通方法的区别

175
00:06:10,780 --> 00:06:13,180
就是它没有返回值的类型

176
00:06:13,580 --> 00:06:15,380
并且他这个构造方法名呢

177
00:06:15,740 --> 00:06:18,420
是与我们的类名是相同的

178
00:06:19,740 --> 00:06:22,100
系统呢是默认提供一个无参构造

179
00:06:22,140 --> 00:06:22,700
其实我们

180
00:06:22,700 --> 00:06:24,460
可以在这里面输入一些参数的啊

181
00:06:26,150 --> 00:06:28,750
构造方法的重载也叫自定义构造

182
00:06:28,750 --> 00:06:29,750
号我们怎么去做呢

183
00:06:30,270 --> 00:06:31,710
当我们系统不再提供

184
00:06:31,990 --> 00:06:34,190
默认的无参构造方法的时候呢

185
00:06:34,470 --> 00:06:36,190
我们可以通过重载的方式

186
00:06:36,310 --> 00:06:38,070
去自定义一些构造方法

187
00:06:38,350 --> 00:06:40,230
比如说在下面这张图中

188
00:06:40,670 --> 00:06:44,790
我们通过输入name health life sexy 的方式

189
00:06:45,230 --> 00:06:47,590
对这些内容进行一些赋值

190
00:06:48,360 --> 00:06:49,720
我们看一下这个代码啊

191
00:06:49,720 --> 00:06:51,680
其实左边其实就是this 点name 

192
00:06:51,680 --> 00:06:54,200
m 就是我们成员属性

193
00:06:54,960 --> 00:06:57,000
右边这个name 就是我们传入的参数

194
00:06:57,240 --> 00:06:58,320
那这个this 关键字呢

195
00:06:58,320 --> 00:07:00,680
就是说对一个对象的默认引用

196
00:07:00,680 --> 00:07:03,520
这里用区分这个同名的成员变量啊

197
00:07:03,810 --> 00:07:05,010
就比如说this 点name 

198
00:07:05,010 --> 00:07:06,010
就是我们的成员变量

199
00:07:06,010 --> 00:07:07,970
而后面的name 就是我们局部参数

200
00:07:08,310 --> 00:07:09,870
那这个时候通过这个构造方法

201
00:07:09,870 --> 00:07:12,590
我就可以把那个name health live 和sexy 

202
00:07:12,800 --> 00:07:13,400
以入参

203
00:07:13,400 --> 00:07:15,200
的形式传入到我们的构造方法中

204
00:07:15,360 --> 00:07:16,760
赋给我们的成员变量

205
00:07:16,920 --> 00:07:18,000
这个时候我们的成员变量

206
00:07:18,320 --> 00:07:20,240
前面都给它进行修改了

207
00:07:20,670 --> 00:07:22,430
这个构造方法就特别的实用

208
00:07:22,990 --> 00:07:24,950
但是我们怎么样去做它

209
00:07:25,310 --> 00:07:27,430
我们就是通过重载的方式去做它

210
00:07:27,720 --> 00:07:29,040
系统会给我们提供一个

211
00:07:29,240 --> 00:07:31,760
相当于这样的无参的一个构造方法

212
00:07:32,430 --> 00:07:33,630
重载的定义叫什么呢

213
00:07:33,870 --> 00:07:35,030
唉我们来归纳一下啊

214
00:07:35,030 --> 00:07:37,550
就是方法名相同比如说这两个

215
00:07:37,550 --> 00:07:38,550
都是叫做什么

216
00:07:38,870 --> 00:07:41,150
p 开头的一个企鹅的一个名称对吧

217
00:07:41,480 --> 00:07:42,920
它是跟类名相同的

218
00:07:42,960 --> 00:07:44,960
它是要构造方法是跟类名相同的

219
00:07:45,120 --> 00:07:45,480
所以它

220
00:07:45,480 --> 00:07:47,560
的方法名相同是重载第一个特点

221
00:07:47,760 --> 00:07:50,120
第二个就是参数的数据类型

222
00:07:50,420 --> 00:07:51,740
或参数个数不同

223
00:07:51,740 --> 00:07:54,100
比如说我们下面是有啊四个参数

224
00:07:54,530 --> 00:07:55,970
那我们上面是没有参数

225
00:07:55,970 --> 00:07:57,650
就是参数的个数不同对吧

226
00:07:57,930 --> 00:08:02,110
还有就是说与返回值访问修饰符无关

227
00:08:02,270 --> 00:08:03,470
哎我们这个地方其实

228
00:08:03,590 --> 00:08:05,590
构造方法是没有返回值的对吧

229
00:08:05,710 --> 00:08:06,910
所以说访问值无关

230
00:08:07,030 --> 00:08:08,590
访问修饰符呢也没有关系

231
00:08:08,590 --> 00:08:09,310
我们这个地方

232
00:08:09,650 --> 00:08:11,210
如果说要换成其他修饰符

233
00:08:11,450 --> 00:08:14,250
两者不一致也可以称为方法的重载

234
00:08:16,550 --> 00:08:18,310
然后我们来看一下方法重载调用啊

235
00:08:18,550 --> 00:08:20,950
比如说我们上来我们通过这个new

236
00:08:21,070 --> 00:08:21,990
企鹅的方式

237
00:08:22,180 --> 00:08:23,100
创造一个对象

238
00:08:23,140 --> 00:08:25,740
这个对象呢通过点print 方式去调用

239
00:08:25,740 --> 00:08:28,140
它的共有的行为叫print 打印出来

240
00:08:28,380 --> 00:08:30,500
然后我们也可以通过什么啊

241
00:08:30,730 --> 00:08:32,610
调用一个有参的构造方法

242
00:08:33,130 --> 00:08:34,210
哎有参的构造方法呢

243
00:08:34,210 --> 00:08:35,890
其实就是说调用这句话

244
00:08:36,049 --> 00:08:37,530
其实就是调用下面的内容

245
00:08:37,530 --> 00:08:39,780
就是把这个名字叫美美

246
00:08:40,299 --> 00:08:42,260
健康值亲密度和她的性别

247
00:08:42,340 --> 00:08:44,100
传入到我们的成员变量中

248
00:08:44,660 --> 00:08:46,500
那当然上面的无参构造就是说

249
00:08:46,700 --> 00:08:47,380
也可以这么写

250
00:08:47,980 --> 00:08:50,300
它的写法不同调用的方式是不同的

251
00:08:50,850 --> 00:08:52,770
其实就是说你这两个方法

252
00:08:52,770 --> 00:08:55,410
就是重载方法的入口是不一样的

253
00:08:55,410 --> 00:08:57,810
所以你最后里面的东西是不一样的

254
00:08:59,460 --> 00:09:02,020
阅读代码并输出运行结果

255
00:09:02,540 --> 00:09:03,420
指出原因

256
00:09:03,540 --> 00:09:04,620
大家看下这个代码啊

257
00:09:05,060 --> 00:09:06,140
这个代码呢就是说

258
00:09:06,590 --> 00:09:08,310
首先有个类叫企鹅类

259
00:09:08,670 --> 00:09:10,430
这个企鹅类里面它有一个昵称

260
00:09:10,430 --> 00:09:11,310
有一个健康值

261
00:09:11,310 --> 00:09:12,190
有一个性别

262
00:09:12,230 --> 00:09:14,830
并且有一个诶这是什么方法对吧

263
00:09:15,070 --> 00:09:17,190
然后最后有一个print 方法对吧

264
00:09:17,340 --> 00:09:18,740
然后这上面是调用它

265
00:09:18,900 --> 00:09:20,940
通过new 的方式去new 了一个

266
00:09:21,180 --> 00:09:23,180
pg n 3的一个企鹅对象

267
00:09:23,410 --> 00:09:25,690
然后通过这个对象呢去点print 方法

268
00:09:26,050 --> 00:09:27,410
那最后这个结果是什么呢

269
00:09:27,570 --> 00:09:28,890
是什么原因导致这个结果

270
00:09:28,890 --> 00:09:30,250
大家去思考一下好吧

271
00:09:31,150 --> 00:09:33,670
诶这个结果呢是什么

272
00:09:33,910 --> 00:09:35,710
企鹅的名字是no 

273
00:09:36,270 --> 00:09:37,550
健康值呢是零

274
00:09:37,870 --> 00:09:38,950
性别是none 

275
00:09:39,190 --> 00:09:40,910
不对呀同学们看到不对呀

276
00:09:40,910 --> 00:09:43,170
对吧我是不是明明在一个地方

277
00:09:43,170 --> 00:09:44,490
把健康值定义为十

278
00:09:44,730 --> 00:09:46,690
性别定义为熊对吧

279
00:09:46,970 --> 00:09:48,850
那为什么我最后呢

280
00:09:49,400 --> 00:09:50,400
我的性别是n 

281
00:09:50,440 --> 00:09:51,600
我的名字还是none 呢

282
00:09:52,400 --> 00:09:53,680
我的健康值还是零呢

283
00:09:54,300 --> 00:09:54,860
是因为我

284
00:09:54,860 --> 00:09:56,700
们可能没有调用这个方法对不对

285
00:09:56,940 --> 00:09:58,260
哎为什么没有调用这个方法

286
00:09:58,260 --> 00:09:59,820
因为我们的构造方法呢

287
00:09:59,820 --> 00:10:02,660
其实它是一个无返回值类型

288
00:10:03,250 --> 00:10:05,570
那我们这个地方是有返回值类型word 

289
00:10:05,570 --> 00:10:07,650
这个word 能代表是我们这个方法

290
00:10:07,650 --> 00:10:08,850
就不是构造方法了

291
00:10:09,200 --> 00:10:11,360
那它就不会通过这个地方调用到

292
00:10:11,360 --> 00:10:12,720
我们这个红框这个地方

293
00:10:13,200 --> 00:10:14,040
所以我们的

294
00:10:14,560 --> 00:10:17,000
性别和我们的健康值都不对

295
00:10:18,480 --> 00:10:21,040
好这段代码大家也看一下啊

296
00:10:21,640 --> 00:10:22,840
哎我们的错误在哪呢

297
00:10:22,880 --> 00:10:25,640
比如说我们这个方法里面叫play 

298
00:10:25,640 --> 00:10:30,200
这个方法这里面有一个int lock rint lock rain 呢

299
00:10:30,200 --> 00:10:32,520
这个变量呢它是一个局部变量

300
00:10:32,600 --> 00:10:34,880
它是没有进行初始化的

301
00:10:35,410 --> 00:10:36,890
在我们实际编程敲的时候

302
00:10:36,890 --> 00:10:39,170
大家可以把代码敲到编译器里

303
00:10:39,250 --> 00:10:40,330
它会报错

304
00:10:40,770 --> 00:10:41,610
报什么错呢

305
00:10:42,150 --> 00:10:43,870
may not have been 初始化

306
00:10:44,070 --> 00:10:44,950
没有被初始化

307
00:10:45,310 --> 00:10:46,390
但是这是

308
00:10:46,390 --> 00:10:48,670
我们编译器里面可以显而易见的看到

309
00:10:48,670 --> 00:10:50,520
但是在我们的考试里面呢

310
00:10:50,520 --> 00:10:51,920
肯定是让我们自己去

311
00:10:52,100 --> 00:10:53,420
一些经验去看到的

312
00:10:53,500 --> 00:10:54,980
所以大家一定要注意这个东西

313
00:10:55,100 --> 00:10:56,260
一个是局部变量

314
00:10:56,260 --> 00:10:56,860
就是我们

315
00:10:56,860 --> 00:10:58,860
方法里面写的这些变量叫局部变量

316
00:10:59,020 --> 00:11:00,940
还有我们方法外面写的这些东西呢

317
00:11:00,940 --> 00:11:01,460
就是方法

318
00:11:01,460 --> 00:11:02,140
外面和类

319
00:11:02,140 --> 00:11:04,140
名下面写的这些东西叫做成员变量

320
00:11:04,420 --> 00:11:05,500
这个要区分清楚

321
00:11:07,140 --> 00:11:08,900
好我们来看一下stle 关键字

322
00:11:09,460 --> 00:11:10,900
为什么会学习时代关键字呢

323
00:11:10,900 --> 00:11:12,060
我们想一下啊

324
00:11:12,480 --> 00:11:13,080
我们是不

325
00:11:13,080 --> 00:11:15,040
是可以通过类名直接访问成员变量呢

326
00:11:15,040 --> 00:11:16,720
因为我们刚才在写代码的过程中

327
00:11:16,720 --> 00:11:18,240
都是要首先new 一个对象

328
00:11:18,240 --> 00:11:19,840
就是通过类new 一个对象

329
00:11:19,840 --> 00:11:20,960
通过对象名呢

330
00:11:21,230 --> 00:11:23,310
点的方法去获取成员变量

331
00:11:23,510 --> 00:11:24,630
是不是要两个步骤

332
00:11:24,990 --> 00:11:25,950
我现在就想啊

333
00:11:25,950 --> 00:11:27,950
我直接通过类名点的方法去获取

334
00:11:28,350 --> 00:11:29,110
那怎么办呢

335
00:11:29,510 --> 00:11:30,230
通过set 关

336
00:11:30,230 --> 00:11:32,310
键字是可以去实现这个功能的啊

337
00:11:32,900 --> 00:11:34,420
之前的一个方式就是说

338
00:11:34,420 --> 00:11:36,260
直接先new 后点sexy 

339
00:11:36,260 --> 00:11:37,380
就是说两个步骤

340
00:11:37,980 --> 00:11:39,940
我们通过stc 关键字来定义变量

341
00:11:39,940 --> 00:11:42,460
就是比如说static final string 

342
00:11:42,740 --> 00:11:43,540
这个东西叫q 

343
00:11:43,540 --> 00:11:44,880
仔其实

344
00:11:44,880 --> 00:11:47,440
这个地方还有一个修饰词叫做final

345
00:11:48,000 --> 00:11:50,040
用final 修饰的变量称为常量

346
00:11:50,160 --> 00:11:51,320
其值是固定不变的

347
00:11:51,720 --> 00:11:54,000
所以说我们把这个常量的名字呢

348
00:11:54,000 --> 00:11:55,880
用这个大写的字母去表示

349
00:11:56,410 --> 00:11:58,170
这个时候这样写完以后呢

350
00:11:58,730 --> 00:11:59,170
我们就可

351
00:11:59,170 --> 00:12:01,210
以直接通过什么类名调用的方式

352
00:12:01,450 --> 00:12:04,330
通过类名点的方式去获取这个性别

353
00:12:05,050 --> 00:12:08,890
static 我们可以定义方法就是static word printer 

354
00:12:09,330 --> 00:12:11,570
我们就可以用这个类名点这个方法

355
00:12:11,770 --> 00:12:12,450
去调用

356
00:12:14,180 --> 00:12:15,740
我们来看一下这个static 呢

357
00:12:15,900 --> 00:12:18,540
修饰与非static 修饰的一个区别好吧

358
00:12:19,190 --> 00:12:21,950
static 非private 的一个修饰呢

359
00:12:22,270 --> 00:12:22,710
它修饰

360
00:12:22,710 --> 00:12:24,910
在属性上面就是类属性和类变量

361
00:12:25,680 --> 00:12:27,680
那face static private 修饰呢

362
00:12:27,680 --> 00:12:28,640
就是修饰在这个

363
00:12:28,800 --> 00:12:30,960
属性上面就是实例属性实例变量

364
00:12:31,490 --> 00:12:33,610
这个非常重要大家一定要仔细听啊

365
00:12:33,610 --> 00:12:34,650
这个东西大家敲黑板

366
00:12:35,130 --> 00:12:37,290
考试中可能会有选择题或者是

367
00:12:37,370 --> 00:12:39,050
填空题的这个方式出现

368
00:12:39,710 --> 00:12:42,350
方法呢就是如果说修饰在方法上面

369
00:12:42,350 --> 00:12:43,350
我们就是类方法

370
00:12:43,790 --> 00:12:45,790
如果是face static 就是实例方法

371
00:12:46,220 --> 00:12:48,660
那调用方式呢唉大家刚才讲了啊

372
00:12:48,990 --> 00:12:50,670
我可以通过类名点属性

373
00:12:50,710 --> 00:12:51,630
类名点方法

374
00:12:51,950 --> 00:12:52,790
对象点属性

375
00:12:52,790 --> 00:12:55,630
对象点方法四种方式去调用它

376
00:12:56,240 --> 00:12:58,440
而我们face static 修饰呢

377
00:12:58,440 --> 00:13:00,000
我们只能通过对象点属性

378
00:13:00,000 --> 00:13:01,880
对象点方法方式去调用

379
00:13:02,210 --> 00:13:04,290
所以说我们通过static 是不是

380
00:13:04,530 --> 00:13:06,490
大大方便了我们的调用呢

381
00:13:06,930 --> 00:13:08,610
那这个归属呢它是属于类的

382
00:13:08,930 --> 00:13:11,010
而这边的方法和属性呢

383
00:13:11,010 --> 00:13:13,290
还是归属于两个对象啊

384
00:13:13,370 --> 00:13:15,210
所以他的级别是不一样的啊

385
00:13:15,610 --> 00:13:17,010
大家一定要注意这个区分

386
00:13:18,680 --> 00:13:19,760
那static 代码

387
00:13:19,760 --> 00:13:22,000
阅读请指出这个下面的一些错误

388
00:13:22,750 --> 00:13:24,350
我们刚才的错误是什么

389
00:13:24,350 --> 00:13:26,550
这个local 是没有初始化的对吧

390
00:13:26,990 --> 00:13:28,350
现在我们给它初始化了

391
00:13:29,030 --> 00:13:29,590
这个地方

392
00:13:29,590 --> 00:13:32,190
呢其实在实例方法里面是不可以定义

393
00:13:32,310 --> 00:13:33,150
static 变量的

394
00:13:33,270 --> 00:13:34,990
那我们如果写到编辑器里面

395
00:13:34,990 --> 00:13:36,350
它直接就会报错了啊

396
00:13:36,600 --> 00:13:39,680
这个地方是only final is permeter 

397
00:13:40,280 --> 00:13:42,440
这个地方只能写一个final static 

398
00:13:42,440 --> 00:13:43,680
是不能写在这里面的

399
00:13:43,960 --> 00:13:45,640
因为static 提升到类级别了

400
00:13:45,640 --> 00:13:47,760
你在这个实例方法中是不能写的

401
00:13:47,760 --> 00:13:48,760
而不是实力级别

402
00:13:49,120 --> 00:13:50,880
我们应该有一个更加清晰的认识

403
00:13:52,660 --> 00:13:54,300
说完刚才这些地方以后呢

404
00:13:54,300 --> 00:13:56,900
我们来讲一下为什么要使用封装

405
00:13:57,300 --> 00:13:59,460
我们看一下下面这个代码有什么缺陷

406
00:13:59,460 --> 00:14:01,460
我们就能理解我们为什么要去

407
00:14:01,820 --> 00:14:02,980
学这个封装了啊

408
00:14:03,410 --> 00:14:05,810
这代码就是dog d 等于new dog 

409
00:14:05,810 --> 00:14:07,610
然后d 点health 等于1000

410
00:14:08,210 --> 00:14:09,010
这个属性

411
00:14:09,050 --> 00:14:09,650
值是不是

412
00:14:09,650 --> 00:14:11,770
通过这个d 点health 的方式去访问呢

413
00:14:12,300 --> 00:14:14,100
这个属性呢我们是可以

414
00:14:14,100 --> 00:14:15,620
是不是可以随意访问的呀

415
00:14:15,880 --> 00:14:17,200
你只要过来给我new 一下

416
00:14:17,200 --> 00:14:18,360
new 完以后我就可以复制

417
00:14:18,360 --> 00:14:19,360
这样就有问题了

418
00:14:19,480 --> 00:14:21,760
那如何解决上面的一些缺陷呢

419
00:14:21,760 --> 00:14:23,040
我们就使用封装

420
00:14:24,340 --> 00:14:25,660
我们来看一下什么是封装

421
00:14:26,460 --> 00:14:29,460
封装是面向对象的三大特征之一

422
00:14:30,060 --> 00:14:33,020
封装的概念是将类的某些信息

423
00:14:33,620 --> 00:14:36,220
隐藏在类的内部

424
00:14:36,590 --> 00:14:39,110
不允许外部程序直接访问

425
00:14:39,430 --> 00:14:40,030
而是通过

426
00:14:40,070 --> 00:14:43,390
该类提供的方法来实现对隐藏信息的

427
00:14:43,630 --> 00:14:44,830
操作和访问

428
00:14:45,320 --> 00:14:46,440
也就是下面这个图

429
00:14:46,920 --> 00:14:48,520
小孩在这个屋子里

430
00:14:48,800 --> 00:14:50,360
正常人是接触不到他的

431
00:14:50,600 --> 00:14:51,880
但是你要想接触它呢

432
00:14:51,880 --> 00:14:54,280
你必须要通过他给你提供的一个

433
00:14:54,640 --> 00:14:55,440
小窗户啊

434
00:14:56,430 --> 00:14:58,670
使用封装它有什么好处呢

435
00:14:59,060 --> 00:15:03,220
首先它只能通过规定的方法访问数据

436
00:15:03,220 --> 00:15:05,380
你只能通过它提供的一个入口

437
00:15:05,500 --> 00:15:07,220
比如说窗户才能进去

438
00:15:07,840 --> 00:15:09,600
方便修改实现

439
00:15:10,480 --> 00:15:12,320
方便加入一些控制语句

440
00:15:12,980 --> 00:15:16,180
还有一点就是说隐藏类的细节信息

441
00:15:16,180 --> 00:15:17,220
这个也很容易理解

442
00:15:17,220 --> 00:15:18,420
这个就是说我们把

443
00:15:18,880 --> 00:15:20,640
整个细节信息给它包裹住

444
00:15:20,640 --> 00:15:21,400
不让你看到

445
00:15:21,840 --> 00:15:23,240
那这些大家可能要记一下

446
00:15:23,520 --> 00:15:26,000
因为这些东西可能在我们的选择填空

447
00:15:26,330 --> 00:15:27,610
判断题中可能会出现

448
00:15:29,410 --> 00:15:30,650
如何去使用封装呢

449
00:15:31,190 --> 00:15:31,790
第一步呢

450
00:15:31,910 --> 00:15:33,870
就是把我们的属性的可见性呢

451
00:15:33,910 --> 00:15:35,030
修改为private

452
00:15:35,630 --> 00:15:38,590
第二步就是创建公有的get set 方法

453
00:15:39,010 --> 00:15:40,330
用于属性的读写

454
00:15:41,100 --> 00:15:42,220
第三步就是在get

455
00:15:42,260 --> 00:15:44,460
set 方法中加入属性的控制语句

456
00:15:44,780 --> 00:15:46,820
对属性值的合法性进行判断

457
00:15:47,500 --> 00:15:48,580
比如说我们前面

458
00:15:49,210 --> 00:15:51,650
随意就可以访问dog 的health

459
00:15:52,010 --> 00:15:53,370
并且对health 进行赋值

460
00:15:53,370 --> 00:15:54,530
赋一个错误的就1000

461
00:15:55,140 --> 00:15:56,020
这个时候我

462
00:15:56,420 --> 00:15:59,060
通过加入一些合法的判断以后

463
00:15:59,060 --> 00:16:00,580
他就不能够随意复制了

464
00:16:01,140 --> 00:16:01,580
那所以这

465
00:16:01,580 --> 00:16:03,460
个地方就解决了之前的一个代码

466
00:16:03,700 --> 00:16:04,420
一个问题

467
00:16:04,980 --> 00:16:07,820
啊我们来阅读一下这个代码啊

468
00:16:08,140 --> 00:16:08,660
首先呢

469
00:16:09,020 --> 00:16:12,100
哎这个dog 他的一个属性有哪些呢

470
00:16:12,300 --> 00:16:14,340
name else love string 对吧

471
00:16:14,500 --> 00:16:15,700
这些东西都是我们

472
00:16:16,110 --> 00:16:17,670
共有的这个狗的一些属性

473
00:16:17,670 --> 00:16:18,190
我们给他

474
00:16:18,390 --> 00:16:20,630
把前面的修饰符全部设置成private

475
00:16:20,630 --> 00:16:22,150
私有的属性那这样呢

476
00:16:22,430 --> 00:16:24,630
外面的人就没有办法直接去访问他

477
00:16:25,150 --> 00:16:26,150
那怎么样去访问它呢

478
00:16:26,150 --> 00:16:27,470
我要给他提供一个路径啊

479
00:16:27,990 --> 00:16:31,140
那怎么办呢设置一些get 方法和set 方法

480
00:16:31,140 --> 00:16:31,700
比如说get

481
00:16:31,780 --> 00:16:34,020
healthy 就是能够获取我们的健康值

482
00:16:34,340 --> 00:16:36,020
那通过调用这个方法以后呢

483
00:16:36,160 --> 00:16:36,680
他就能够

484
00:16:36,680 --> 00:16:39,240
得到我们内部的health 这个信息对吧

485
00:16:39,240 --> 00:16:41,240
这就是我提供给他的一个方法

486
00:16:41,560 --> 00:16:43,080
那我要去修改这个healthy 呢

487
00:16:43,080 --> 00:16:45,400
我就要使用这个set 方法

488
00:16:45,820 --> 00:16:48,140
那使用set 方法比如说我传入个healthy 

489
00:16:48,140 --> 00:16:49,780
然后对这个healthy 进行赋值

490
00:16:50,880 --> 00:16:54,240
当然在复制前我是给他一个判断语句

491
00:16:54,790 --> 00:16:55,230
比如说我

492
00:16:55,230 --> 00:16:57,670
的healthy 是大于100小于零这个区间内的

493
00:16:57,790 --> 00:16:59,550
我就不能够对它进行复制

494
00:17:00,320 --> 00:17:02,960
那这就是我们对它进行了一个控制

495
00:17:03,440 --> 00:17:05,720
大家听明白这个举例子以后就能够

496
00:17:05,920 --> 00:17:07,920
明白我们封装做的事情

497
00:17:08,510 --> 00:17:10,190
好我们来看一下旁边的类图啊

498
00:17:10,190 --> 00:17:14,050
我们要善于去把这个类抽象成类图

499
00:17:14,369 --> 00:17:17,250
并且把类图呢转换成我们的编码啊

500
00:17:17,450 --> 00:17:18,810
我们要具备这个能力啊

501
00:17:18,810 --> 00:17:19,890
这是一个设计能力

502
00:17:20,460 --> 00:17:22,690
我们来看一下这个dog 呢有哪些属性

503
00:17:23,050 --> 00:17:25,089
我们就类图里面就有哪些属性对吧

504
00:17:25,089 --> 00:17:26,730
前面都是私有的方法

505
00:17:26,730 --> 00:17:27,810
所以我们都把这个

506
00:17:28,010 --> 00:17:29,970
之前的加号呢变成了减号

507
00:17:30,190 --> 00:17:31,430
那后面就是我们这个

508
00:17:31,670 --> 00:17:33,290
属性的一个一个类型

509
00:17:33,410 --> 00:17:35,650
那下面呢就是我们的属性的一些方法

510
00:17:35,650 --> 00:17:37,170
比如说除了print 以后呢

511
00:17:37,370 --> 00:17:39,450
我们也加入了一些get set 方法

512
00:17:39,690 --> 00:17:42,050
那这些方法前面都是公开的一个属性

513
00:17:42,050 --> 00:17:43,770
所以说是加号

514
00:17:44,270 --> 00:17:46,110
后面就是它的一个返回值类型

515
00:17:46,900 --> 00:17:47,420
大家通过

516
00:17:47,420 --> 00:17:49,500
这代码就能够对我们封装的概念

517
00:17:49,820 --> 00:17:51,100
得到进一步的一个理解

518
00:17:51,620 --> 00:17:52,020
第一步

519
00:17:52,060 --> 00:17:52,540
第二步

520
00:17:52,540 --> 00:17:53,140
第三步

521
00:17:53,940 --> 00:17:54,820
那我们看一下啊

522
00:17:55,140 --> 00:17:55,940
像这个this 呢

523
00:17:55,940 --> 00:17:57,340
我们刚才老师也说过了啊

524
00:17:57,460 --> 00:17:59,900
这个this 点health 就代表我们的成员

525
00:18:00,540 --> 00:18:02,300
这个health 指的就是我们的一个

526
00:18:02,700 --> 00:18:03,780
传入进来的入参

527
00:18:04,250 --> 00:18:05,610
在我们的编译器里面

528
00:18:05,610 --> 00:18:07,250
我们可以通过一些快捷键的方式

529
00:18:07,250 --> 00:18:09,530
去自动生成我们的get set 方法

530
00:18:11,560 --> 00:18:13,800
我们来看一看this 这个关键字的使用啊

531
00:18:14,280 --> 00:18:17,080
我们通过this 点health 来调用一个属性

532
00:18:17,550 --> 00:18:19,630
通过this 点name 来调用一个名字

533
00:18:20,350 --> 00:18:22,750
调用方法就是通过this 点print 方式

534
00:18:23,000 --> 00:18:24,800
还调用构造方法就是this 啊

535
00:18:24,800 --> 00:18:25,760
这是无参构造

536
00:18:26,120 --> 00:18:27,800
还调用有参构造那就是this

537
00:18:28,160 --> 00:18:29,840
括号里面传入了一些参数

538
00:18:30,290 --> 00:18:31,890
我们来看一下如果要使用的话

539
00:18:32,370 --> 00:18:34,330
必须是构造方法中的第一条语句

540
00:18:36,150 --> 00:18:38,150
学习的东西呢我们进行了一个总结

541
00:18:38,740 --> 00:18:41,140
我们抽象和封装这一节里面东西呢

542
00:18:41,140 --> 00:18:42,340
我们主要是讲了一些

543
00:18:42,620 --> 00:18:45,140
面向对象的思想的开发程序的好处

544
00:18:45,730 --> 00:18:48,410
然后呢从现实世界中抽象出类

545
00:18:48,790 --> 00:18:50,710
使用这个现实世界抽象数类呢

546
00:18:50,710 --> 00:18:52,710
首先是找出名词确定类的属性

547
00:18:53,030 --> 00:18:55,950
其次呢是找出动词的确定方法

548
00:18:56,260 --> 00:18:58,460
剔除与业务般的属性和方法

549
00:18:58,870 --> 00:19:00,390
那方法重载有哪些呢

550
00:19:00,390 --> 00:19:02,190
方法重载我们刚才也说了啊

551
00:19:02,190 --> 00:19:03,270
有参构造无参构造

552
00:19:03,270 --> 00:19:05,710
它可能是区别就是参数项不同

553
00:19:05,950 --> 00:19:07,630
还有就是方法名是相同的

554
00:19:07,870 --> 00:19:10,830
与访问的修饰符和返回值无关

555
00:19:11,400 --> 00:19:13,000
那static 呢是可以干什么

556
00:19:13,000 --> 00:19:15,360
可以修饰属性方法静态块

557
00:19:15,600 --> 00:19:17,600
static 使用以后我们就可以

558
00:19:17,890 --> 00:19:19,370
通过类名点属性

559
00:19:19,370 --> 00:19:21,250
类名点方法的形式进行访问

560
00:19:21,970 --> 00:19:23,490
最后是我们的封装的步骤

561
00:19:23,730 --> 00:19:25,010
我们怎么去使用封装呢

562
00:19:25,010 --> 00:19:27,210
首先我们要修改属性的可见值

563
00:19:27,450 --> 00:19:30,360
把属性的可见值通过public 修改成private 

564
00:19:30,560 --> 00:19:31,840
这样我们的其他

565
00:19:32,120 --> 00:19:34,360
对象呢就无法去随意去访问它

566
00:19:34,700 --> 00:19:37,180
最后呢创建一个get set 方法

567
00:19:37,180 --> 00:19:38,820
让别人能够去访问对吧

568
00:19:38,860 --> 00:19:39,340
那访问的

569
00:19:39,340 --> 00:19:39,780
过程中

570
00:19:39,780 --> 00:19:42,100
是需要加入一些属性的控制语句

571
00:19:42,600 --> 00:19:44,080
比如说你不满足我的条件

572
00:19:44,240 --> 00:19:46,040
你随便赋值我是不让你付的

573
00:19:46,200 --> 00:19:48,160
这样就能够提升程序的安全性

574
00:19:49,730 --> 00:19:51,930
看一下例题根据以下信息呢

575
00:19:51,930 --> 00:19:54,430
设计宠物类类型有狗啊

576
00:19:54,590 --> 00:19:55,630
狗有哪些东西啊

577
00:19:55,790 --> 00:19:56,630
哪些行为啊

578
00:19:56,950 --> 00:19:58,110
企鹅有哪些属性啊

579
00:19:58,110 --> 00:19:58,750
哪些行为啊

580
00:19:58,750 --> 00:20:00,310
我们来设计一下类图

581
00:20:01,150 --> 00:20:03,600
bug 和企鹅所有的属性呢

582
00:20:03,600 --> 00:20:04,720
它前面都是减号

583
00:20:04,800 --> 00:20:06,760
就代表我们给它设置成一个私有

584
00:20:06,960 --> 00:20:08,560
通过get set 的方法去访问

585
00:20:08,560 --> 00:20:09,680
就是个封装的形式

586
00:20:10,000 --> 00:20:11,040
这是安全的形式

587
00:20:11,500 --> 00:20:13,100
那下面所以有get set 方法

588
00:20:13,300 --> 00:20:15,220
这些方法前面都是一个公开的属性

589
00:20:15,220 --> 00:20:16,020
就是加号

590
00:20:16,460 --> 00:20:18,380
然后后面都是一个方法的返回值类型

591
00:20:18,380 --> 00:20:19,780
上面是一个属性的类型

592
00:20:20,180 --> 00:20:21,260
这就是我们类图

593
00:20:21,580 --> 00:20:24,060
那通过类图呢学习我们就能知道

594
00:20:24,420 --> 00:20:27,840
如何把一个代码抽象成一个图的形式

595
00:20:27,840 --> 00:20:28,880
这样方便我们对

596
00:20:29,000 --> 00:20:31,000
整个代码进行一个管理和维护

597
00:20:32,050 --> 00:20:34,370
而根据类图呢编写dog 类呢

598
00:20:34,370 --> 00:20:37,530
和起源类添加默认的构造方法啊

599
00:20:38,130 --> 00:20:40,080
比如说哎我们狗类呢

600
00:20:40,080 --> 00:20:41,120
我们有哪些属性呢

601
00:20:41,120 --> 00:20:42,880
我们给它哎都列一下对吧

602
00:20:43,160 --> 00:20:43,880
还有哪些

603
00:20:44,280 --> 00:20:45,440
就是无参构造方法

604
00:20:45,440 --> 00:20:46,600
我们在里面加了啊

605
00:20:46,870 --> 00:20:48,710
有参构造方法我们这边也写了

606
00:20:48,710 --> 00:20:49,070
对不对

607
00:20:49,270 --> 00:20:50,470
然后有一些方法呀

608
00:20:50,470 --> 00:20:51,510
get 方法set 的方法

609
00:20:51,510 --> 00:20:53,350
包括一些他自己的属性的方法

610
00:20:53,350 --> 00:20:55,070
就是吃啊玩啊对吧

611
00:20:55,310 --> 00:20:57,190
这是set 支持set 支持set 

612
00:20:57,190 --> 00:20:57,470
对吧

613
00:20:57,750 --> 00:21:00,380
还有包括等等的一些后面的一些方法

614
00:21:00,380 --> 00:21:01,100
print 的方法

615
00:21:01,100 --> 00:21:02,460
那企鹅也是同样的啊

616
00:21:02,460 --> 00:21:04,060
这个我就不详细去讲

617
00:21:04,300 --> 00:21:05,860
这个其实非常简单对吧

618
00:21:07,630 --> 00:21:08,230
好第二题

619
00:21:08,630 --> 00:21:11,870
是类方法中可以直接调用对象变量吗

620
00:21:12,570 --> 00:21:13,370
不可以的啊

621
00:21:13,970 --> 00:21:14,490
因为静态

622
00:21:14,490 --> 00:21:15,130
方法在类

623
00:21:15,130 --> 00:21:17,210
加载的时候就需要初始化对象变量

624
00:21:17,210 --> 00:21:20,650
需要在新建对象new 之后才能够使用

625
00:21:21,260 --> 00:21:22,260
第三题是

626
00:21:22,260 --> 00:21:25,740
以下关于java 封装的描述中正确的是a

627
00:21:25,940 --> 00:21:26,340
对吧

628
00:21:26,970 --> 00:21:28,210
封装主要作用是

629
00:21:28,650 --> 00:21:31,650
在于对外隐藏内部的实现细节

630
00:21:31,650 --> 00:21:33,130
增加程序的安全性

631
00:21:33,530 --> 00:21:34,650
所以a 是对的啊

632
00:21:36,220 --> 00:21:38,740
第四题这个代码段的一个结果是什么

633
00:21:38,740 --> 00:21:39,300
这是程序

634
00:21:39,300 --> 00:21:41,500
阅读题在我们考试中经常出现啊

635
00:21:42,200 --> 00:21:43,720
我们答案是自己编译出错

636
00:21:43,720 --> 00:21:44,640
为什么呢唉

637
00:21:44,640 --> 00:21:45,670
因为我们

638
00:21:45,670 --> 00:21:46,310
java 的静态

639
00:21:46,310 --> 00:21:48,350
方法是不能够访问非静态变量的

640
00:21:48,430 --> 00:21:50,870
如果要做的话需要把前面加上steady 

641
00:21:51,230 --> 00:21:52,150
答案才会是零

642
00:21:52,150 --> 00:21:53,030
不然就会错

643
00:21:53,590 --> 00:21:55,870
同样在static 方法中是不能够

644
00:21:56,070 --> 00:21:57,350
访问非静态变量的

645
00:21:58,610 --> 00:21:59,370
创建程序

646
00:21:59,850 --> 00:22:02,610
其中定义两个类体会java 的封装性

647
00:22:03,050 --> 00:22:05,970
account 类有姓名余额密码

648
00:22:06,290 --> 00:22:07,210
如果不满足会

649
00:22:07,250 --> 00:22:09,370
给出提示信息并给出默认值

650
00:22:09,750 --> 00:22:13,310
然后通过set 的方法给account 的属性赋值

651
00:22:13,510 --> 00:22:15,270
最后在测试类中进行测试

652
00:22:15,550 --> 00:22:17,510
这个就是我们说的封装三步骤

653
00:22:17,830 --> 00:22:19,870
前面已经讲了很多这个例子了

654
00:22:19,910 --> 00:22:21,390
看一下实际的编码怎么去写

655
00:22:22,350 --> 00:22:24,190
我们首先定义account 这个类

656
00:22:24,230 --> 00:22:25,550
把这个类里面有属性

657
00:22:26,020 --> 00:22:27,260
有哪些属性的名字

658
00:22:27,860 --> 00:22:29,260
余额和密码对吧

659
00:22:29,580 --> 00:22:31,260
然后通过有参构造的方式

660
00:22:31,740 --> 00:22:33,020
进行赋值对吧

661
00:22:33,340 --> 00:22:34,340
那赋值的时候呢

662
00:22:34,380 --> 00:22:36,380
我们要记得我们要给他get set 方法

663
00:22:36,380 --> 00:22:36,820
为什么呢

664
00:22:36,820 --> 00:22:37,180
因为我

665
00:22:37,180 --> 00:22:39,340
们在属性的时候就已经把所有的

666
00:22:39,560 --> 00:22:41,840
类型设置成一个私有的

667
00:22:41,840 --> 00:22:43,040
让它不能够访问了

668
00:22:43,120 --> 00:22:45,040
所以说我们要给他一个方法去访问

669
00:22:45,300 --> 00:22:46,420
比如说set 方法的时候

670
00:22:46,420 --> 00:22:48,900
我们要判断我们不能随意让他去修改

671
00:22:48,900 --> 00:22:51,500
我们值只有满足我们的条件的时候

672
00:22:51,500 --> 00:22:52,940
我们才能够给他去修改

673
00:22:53,600 --> 00:22:56,240
然后最后呃下面密码也是同样的

674
00:22:56,240 --> 00:22:57,680
给他满足微信行业程序修改

675
00:22:57,760 --> 00:23:00,120
最后呢我们创建了一个测试类

676
00:23:00,690 --> 00:23:04,010
把我们这个对象进行一个什么实例化

677
00:23:04,370 --> 00:23:06,130
哎进行一个info 打印一下

678
00:23:06,130 --> 00:23:07,770
就能把最后结果弄出来

679
00:23:08,250 --> 00:23:09,250
很简单一件事

680
00:23:09,760 --> 00:23:12,040
这个地方就是考验大家对封装的理解

681
00:23:12,040 --> 00:23:13,840
封装三个步骤老师再总结一下

682
00:23:14,080 --> 00:23:16,640
首先呢是把我们的成员属性

683
00:23:17,030 --> 00:23:19,310
的修饰符改成了private 私有答案

684
00:23:19,310 --> 00:23:21,510
第二个步骤就是给出get set 方法

685
00:23:21,990 --> 00:23:23,860
来让别人能够访问你

686
00:23:24,060 --> 00:23:25,420
第三个就是说在get

687
00:23:25,580 --> 00:23:27,980
set 方法中你加入了一些控制语句

688
00:23:28,380 --> 00:23:30,620
控制别人访问你的一些方式

689
00:23:30,780 --> 00:23:32,540
这是非常重要的一个步骤

690
00:23:32,740 --> 00:23:33,860
那封装整

691
00:23:33,860 --> 00:23:36,260
体上就能够解决我们程序的一个安全

692
00:23:36,300 --> 00:23:37,180
漏洞的问题

693
00:23:38,640 --> 00:23:39,200
练习题呢

694
00:23:39,200 --> 00:23:39,520
大家可

695
00:23:39,520 --> 00:23:41,400
以课后看一下去做一下这个题目

696
00:23:42,980 --> 00:23:44,580
那本科结束谢谢大家
